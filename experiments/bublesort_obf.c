/* Generated by CIL v. 1.7.0 */
/* print_CIL_Input is false */

struct _1_sort__opaque_Node_1;
struct _IO_FILE;
struct timeval;
extern float strtof(char const   *str , char const   *endptr ) ;
extern void signal(int sig , void *func ) ;
typedef struct _IO_FILE FILE;
extern double strtod(char const   *str , char const   *endptr ) ;
extern int fclose(void *stream ) ;
extern void *fopen(char const   *filename , char const   *mode ) ;
extern void abort() ;
extern void exit(int status ) ;
extern int raise(int sig ) ;
extern int fprintf(struct _IO_FILE *stream , char const   *format  , ...) ;
extern int rand() ;
extern unsigned long strtoul(char const   *str , char const   *endptr , int base ) ;
typedef struct _1_sort__opaque_Node_1 *_1_sort__opaque_List_1;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned long maxlen ) ;
struct _1_sort__opaque_Node_1 {
   int data ;
   struct _1_sort__opaque_Node_1 *next ;
};
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list2_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern int gettimeofday(struct timeval *tv , void *tz  , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
int main(void) ;
extern unsigned long strlen(char const   *s ) ;
void sort(unsigned char *mlist , unsigned int size ) ;
void megaInit(void) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list1_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern unsigned long strnlen(char const   *s , unsigned long maxlen ) ;
extern void *memcpy(void *s1 , void const   *s2 , unsigned long size ) ;
struct timeval {
   long tv_sec ;
   long tv_usec ;
};
extern void *malloc(unsigned long size ) ;
extern int scanf(char const   *format  , ...) ;
void sort(unsigned char *mlist , unsigned int size ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned char tmp ;
  int i6 ;
  int r7 ;
  struct _1_sort__opaque_Node_1 *p8 ;
  int _1_sort__BEGIN_0 ;
  int _1_sort__END_0 ;
  int _1_sort__BARRIER_1 ;
  unsigned long _2_sort_next ;

  {
  {  /* __blockattribute__(__ATOMIC__)*/ 
  _1_sort__BEGIN_0 = 1;
  i6 = 0;
  while (i6 < 2) {
    r7 = rand();
    p8 = (struct _1_sort__opaque_Node_1 *)malloc(sizeof(struct _1_sort__opaque_Node_1 ));
    if (p8 != (struct _1_sort__opaque_Node_1 *)0UL) {
      p8->data = r7;
      if (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) {
        p8->next = _1_sort__opaque_list1_1->next;
        _1_sort__opaque_list1_1->next = p8;
      } else {
        p8->next = p8;
        _1_sort__opaque_list1_1 = p8;
      }
    } else {

    }
    i6 ++;
  }
  _1_sort__opaque_list2_1 = _1_sort__opaque_list1_1;
  _1_sort__END_0 = 1;
  }
  _1_sort__BARRIER_1 = 1;
  _2_sort_next = 12 * ! (_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL);
  while (1) {
    switch (_2_sort_next) {
    case 0: ;
    return;
    break;
    case 10: ;
    if (i < size - 1U) {
      _2_sort_next = 8 + (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    } else {
      _2_sort_next = (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1);
    }
    break;
    case 12: 
    i = 0U;
    _2_sort_next = 10 - ! (_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL);
    break;
    case 4: ;
    if ((int )*(mlist + j) > (int )*(mlist + (j + 1U))) {
      _2_sort_next = ((unsigned long )(_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)) + ((unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1);
    } else {
      _2_sort_next = (unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1;
    }
    break;
    case 14: 
    *(mlist + j) = *(mlist + (j + 1U));
    _2_sort_next = _1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL ? 13 : 5;
    break;
    case 2: 
    j ++;
    _2_sort_next = 6 - (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    break;
    case 13: 
    *(mlist + (j + 1U)) = tmp;
    _2_sort_next = ((unsigned long )(_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL) + (unsigned long )(_1_sort__opaque_list1_1 == _1_sort__opaque_list2_1)) + 1;
    break;
    case 8: 
    j = 0U;
    _2_sort_next = _1_sort__opaque_list1_1 != _1_sort__opaque_list2_1 ? 2 : 6;
    break;
    case 6: ;
    if (j < (size - 1U) - i) {
      _2_sort_next = 4 + ((_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1));
    } else {
      _2_sort_next = (unsigned long )(! ((unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)));
    }
    break;
    case 1: 
    i ++;
    _2_sort_next = 10 - ((_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL));
    break;
    case 3: 
    tmp = *(mlist + j);
    _2_sort_next = 14 - ((_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL) + (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL));
    break;
    }
  }
}
}
int main(void) 
{ 
  unsigned char read_list[5] ;
  unsigned int i ;

  {
  megaInit();
  read_list[0] = (unsigned char)2;
  read_list[1] = (unsigned char)5;
  read_list[2] = (unsigned char)3;
  read_list[3] = (unsigned char)6;
  read_list[4] = (unsigned char)1;
  sort(read_list, 5U);
  i = 0U;
  while (i < 5U) {
    printf((char const   */* __restrict  */)"%d", (int )read_list[i]);
    i ++;
  }
  printf((char const   */* __restrict  */)"\n");
  return (0);
}
}
void megaInit(void) 
{ 


  {

}
}
