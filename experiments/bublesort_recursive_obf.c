/* Generated by CIL v. 1.7.0 */
/* print_CIL_Input is false */

struct _1_sort__opaque_Node_1;
struct _IO_FILE;
struct timeval;
extern float strtof(char const   *str , char const   *endptr ) ;
extern void signal(int sig , void *func ) ;
typedef unsigned long size_t;
typedef struct _IO_FILE FILE;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern double strtod(char const   *str , char const   *endptr ) ;
extern int fclose(void *stream ) ;
extern void *fopen(char const   *filename , char const   *mode ) ;
extern void abort() ;
extern void exit(int status ) ;
extern int raise(int sig ) ;
extern int fprintf(struct _IO_FILE *stream , char const   *format  , ...) ;
extern int rand() ;
extern unsigned long strtoul(char const   *str , char const   *endptr , int base ) ;
typedef struct _1_sort__opaque_Node_1 *_1_sort__opaque_List_1;
struct _1_sort__opaque_Node_1 {
   int data ;
   struct _1_sort__opaque_Node_1 *next ;
};
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list2_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned long maxlen ) ;
extern int gettimeofday(struct timeval *tv , void *tz  , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
int main(int argc , char **argv ) ;
void megaInit(void) ;
extern unsigned long strlen(char const   *s ) ;
void sort(int *mlist , int size ) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list1_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern unsigned long strnlen(char const   *s , unsigned long maxlen ) ;
extern void *memcpy(void *s1 , void const   *s2 , unsigned long size ) ;
struct timeval {
   long tv_sec ;
   long tv_usec ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern int scanf(char const   *format  , ...) ;
void megaInit(void) 
{ 


  {

}
}
int main(int argc , char **argv ) 
{ 
  int lsize ;
  int tmp ;
  int *list ;
  void *tmp___0 ;
  int i ;
  int i___0 ;

  {
  megaInit();
  tmp = atoi((char const   *)*(argv + 1));
  lsize = tmp;
  tmp___0 = malloc((unsigned long )lsize * sizeof(int ));
  list = (int *)tmp___0;
  i = 0;
  while (i < lsize) {
    *(list + i) = atoi((char const   *)*(argv + (2 + i)));
    i ++;
  }
  sort(list, lsize);
  i___0 = 0;
  while (i___0 < lsize) {
    printf((char const   */* __restrict  */)"%d", *(list + i___0));
    i___0 ++;
  }
  printf((char const   */* __restrict  */)"\n");
  return (0);
}
}
void sort(int *mlist , int size ) 
{ 
  int i ;
  int tmp ;
  int i5 ;
  int r6 ;
  struct _1_sort__opaque_Node_1 *p7 ;
  int _1_sort__BEGIN_0 ;
  int _1_sort__END_0 ;
  int _1_sort__BARRIER_1 ;
  unsigned long _2_sort_next ;

  {
  {  /* __blockattribute__(__ATOMIC__)*/ 
  _1_sort__BEGIN_0 = 1;
  i5 = 0;
  while (i5 < 2) {
    r6 = rand();
    p7 = (struct _1_sort__opaque_Node_1 *)malloc(sizeof(struct _1_sort__opaque_Node_1 ));
    if (p7 != (struct _1_sort__opaque_Node_1 *)0UL) {
      p7->data = r6;
      if (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) {
        p7->next = _1_sort__opaque_list1_1->next;
        _1_sort__opaque_list1_1->next = p7;
      } else {
        p7->next = p7;
        _1_sort__opaque_list1_1 = p7;
      }
    } else {

    }
    i5 ++;
  }
  _1_sort__opaque_list2_1 = _1_sort__opaque_list1_1;
  _1_sort__END_0 = 1;
  }
  _1_sort__BARRIER_1 = 1;
  _2_sort_next = _1_sort__opaque_list1_1 != _1_sort__opaque_list2_1 ? 10 >> tmp : 10;
  while (1) {
    switch (_2_sort_next) {
    case 0: ;
    return;
    break;
    case 9: ;
    if (size > 1) {
      _2_sort_next = 8 + (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    } else {
      _2_sort_next = (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1);
    }
    break;
    case 10: ;
    _2_sort_next = 9 - ! (_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL);
    break;
    case 4: ;
    if (*(mlist + i) > *(mlist + (i + 1))) {
      _2_sort_next = ((unsigned long )(_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)) + ((unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1);
    } else {
      _2_sort_next = (unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1;
    }
    break;
    case 12: 
    *(mlist + i) = *(mlist + (i + 1));
    _2_sort_next = _1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL ? 11 : 5;
    break;
    case 2: 
    i ++;
    _2_sort_next = _1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL ? i5 : 6;
    break;
    case 11: 
    *(mlist + (i + 1)) = tmp;
    _2_sort_next = ((unsigned long )(_1_sort__opaque_list1_1 == _1_sort__opaque_list2_1) - (unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)) + (unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1)));
    break;
    case 8: 
    i = 0;
    _2_sort_next = _1_sort__opaque_list1_1 != _1_sort__opaque_list2_1 ? 6 & 10 : 6;
    break;
    case 6: ;
    if (i < size - 1) {
      _2_sort_next = _1_sort__opaque_list1_1 != _1_sort__opaque_list2_1 ? size : 4;
    } else {
      _2_sort_next = (unsigned long )(_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    }
    break;
    case 1: 
    sort(mlist, size - 1);
    _2_sort_next = (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1);
    break;
    case 3: 
    tmp = *(mlist + i);
    _2_sort_next = 12 - ((_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL));
    break;
    }
  }
}
}
